{
  "name": "nodehun",
  "version": "0.2.5",
  "description": "The Hunspell binding for nodejs that exposes as much of hunspell as possible and also adds new features. Hunspell is a first class spellcheck api used by Google, Apple, and Mozilla.",
  "main": "build/Release/nodehun",
  "directories": {
    "test": "tests"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "install": "node-gyp rebuild"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/nathanjsweet/nodehun.git"
  },
  "keywords": [
    "spell",
    "spellcheck",
    "spellchecker",
    "hunspell",
    "spell check",
    "spell checker",
    "check"
  ],
  "author": {
    "name": "Nathan Sweet"
  },
  "license": "MIT",
  "gypfile": true,
  "readme": "Nodehun\n=======\nWarning on Versions\n-------------------\n~~The current versions of nodehun (1.XX.XX) supports some different method signature than the earlier versions (0.XX.XX). The method signatures differ when an earlier version passed the first argument as a success parameter of the method, when really an error should be null or passed if something went wrong. Where possible the 0 and 1 version will have the same bug fixes. Here is an example of how they would differ~~ What is crossed out will be true, soon. Right now these changes are being tested. The old/stable version of nodehun is 0.2.6 and the unstable/new-signature version is 0.2.5, this is how they differ, and the documentation hereafter reflects the new signature documentation:\n\n```js\n//0.XX.XX version:\ndict.addWord('foo',function(success, word){\n   console.log(success, word);\n   // if the method succeeded then\n   // the output will be : true, 'foo'\nn}); \n//1.XX.XX version:\ndict.addWord('xxxxxxx', function(err, word){\n   console.log(err);\n   // if the method succeeded then\n   // the output will be: null, 'foo'\n});\n```\n\nInstallation\n------------\nNodehun has no \"node_module\" dependencies (yet), so it can either be installed via npm or simply checked out of git. You'll need [node-gyp](https://github.com/TooTallNate/node-gyp) to build. Nodehun should work on Windows or Unix. You'll also need to make sure that libuv source\ncode is on your system. Usually having node installed is enough, but there are weird cases.\n\n\tnpm install nodehun\n\n\nIntroduction\n------------\nYes there are already two nodejs spell checkers based of off hunspell, but one doesn't seem to even be supported anymore, and the other seems to only support simple spelling suggestions. Nodehun aims to expose as much of hunspell's functionality as possible in an easy to understand and maintain way, while also offering additional functionality not even present in hunspell.\n\nSpell Suggest and Initialization\n--------------------------------\nInitializing nodehun is very easy, simply add the buffer of an affix and dictionary file as the first two arguments of the constructor. The mechanics of the dictionaries nodehun processes is fairly simple to understand. Nodehun ships with US english and Canadian English (look in the examples folder), but tons of languages are available for free at [open office](http://extensions.services.openoffice.org/dictionary), see the readme file in the dictionaries folder for more directions. Of course you don't need to use the filesystem you could use a distributed data store to store the dictionaries. Please do not actually use `readFileSync`.\n\n```js\nvar nodehun = require('nodehun');\nvar affbuf = fs.readFileSync(somedirectory+'/en_US.aff');\nvar dictbuf = fs.readFileSync(somedirectory+'/en_US.dic');\nvar dict = new nodehun(affbuf,dictbuf);\ndict.spellSuggest('color',function(err, correct, suggestion){\n\tconsole.log(err, correct, suggestion);\n\t// because \"color\" is a defined word in the US English dictionary\n\t// the output will be: null, true, null\n});\n\ndict.spellSuggest('calor',function(err, correct, suggestion){\n\tconsole.log(err, correct, suggestion);\n\t// because \"calor\" is not a defined word in the US English dictionary\n\t// the output will be: null, false, \"carol\"\n});\n```\n\nSpell Suggestions\n-----------------\nNodehun also offers a method that returns an array of words that could possibly match a misspelled word, ordered by most likely to be correct.\n\n```js\nvar nodehun = require('nodehun');\nvar affbuf = fs.readFileSync(somedirectory+'/en_US.aff');\nvar dictbuf = fs.readFileSync(somedirectory+'/en_US.dic');\nvar dict = new nodehun(affbuf,dictbuf);\n\ndict.spellSuggestions('color',function(err, correct, suggestions){\n\tconsole.log(err, correct, suggestions);\n\t// because \"color\" is a defined word in the US English dictionary\n\t// the output will be: null, true, []\n});\n\ndict.spellSuggestions('calor',function(a,b){\n\tconsole.log(err, correct, suggestions);\n\t// because \"calor\" is not a defined word in the US English dictionary\n\t// the output will be: null, false, [ 'carol','valor','color','cal or','cal-or','caloric','calorie']\n});\n```\n\nAdd Dictionary\n--------------\nNodehun also can add another dictionary on top of an existing dictionary object at runtime (this means it is not permanent) in order to merge two dictionaries. Once again, please do not actually use `readFileSync`.\n\n```js\nvar nodehun = require('nodehun');\nvar affbuf = fs.readFileSync(somedirectory+'/en_US.aff');\nvar dictbuf = fs.readFileSync(somedirectory+'/en_US.dic');\nvar dictbuf2 = fs.readFileSync(somedirectory+'/en_CA.dic');\nvar dict = new nodehun(affbuf,dictbuf);\n\ndict.spellSuggest('colour',function(err, correct, suggestion){\n\tconsole.log(err, correct, suggestion);\n\t// because \"colour\" is not a defined word in the US English dictionary\n\t// the output will be: null, false, \"color\"\n});\n\ndict.addDictionary(dictbuf2,function(err){\n\tif(!err)\n\t\tUSDictionary.spellSuggest('colour',function(err, correct, suggestion){\n\t\t\tconsole.log(err, correct, suggestion);\n\t\t\t// because \"colour\" is a defined word in the Canadian English dictionary\n\t\t\t// the output will be: null, true, null\n\t\t});\t\t\t\t\n});\n```\n\nAdd Word\n--------\nNodehun can also add a single word to a dictionary at runtime (this means it is not permanent) in order to have a custom runtime dictionary. If you know anything about Hunspell you can also add flags to the word.\n\n```js\nvar nodehun = require('nodehun');\nvar affbuf = fs.readFileSync(somedirectory+'/en_US.aff');\nvar dictbuf = fs.readFileSync(somedirectory+'/en_US.dic');\nvar dict = new nodehun(affbuf,dictbuf);\n\ndict.spellSuggest('colour',function(err, correct, suggestion){\n\tconsole.log(err, correct, suggestions);\n\t// because \"colour\" is not a defined word in the US English dictionary\n\t// the output will be: null, false, \"color\"\n});\n\ndict.addWord('colour',function(err, word){\n\tif(!err)\n\t\tdict.spellSuggest('colour',function(a,b){\n\t\t\tconsole.log(a,b);\n\t\t\t// because \"colour\" has been added to the US dictionary object.\n\t\t\t// the output will be: true, null\n\t\t});\n\n});\n```\n\nRemove Word\n-----------\nNodehun can also remove a single word from a dictionary at runtime (this means it is not permanent) in order to have a custom runtime dictionary. If you know anything about Hunspell this method will ignore flags and just strip words that match.\n\n```js\nvar nodehun = require('nodehun');\nvar affbuf = fs.readFileSync(somedirectory+'/en_US.aff');\nvar dictbuf = fs.readFileSync(somedirectory+'/en_US.dic');\nvar dict = new nodehun(affbuf,dictbuf);\n\ndict.spellSuggest('color',function(err, correct, suggestion){\n\tconsole.log(err, correct, suggestion);\n\t// because \"color\" is a defined word in the US English dictionary\n\t// the output will be: null, true, null\n});\n\ndict.removeWord('color',function(err, word){\n\tif(!err)\t\t\t\n\t\tdict.spellSuggest('color',function(err, correct, suggestion){\n\t\t\tconsole.log(err, correct, suggestion);\n\t\t\t// because \"color\" has been removed from the US dictionary object.\n\t\t\t// the output will be: null, false, \"colors\"\n\t\t\t// note that plurals are considered separte words.\n\t\t});\n\n});\n```\n\nStem\n----\nNodehun exposes the Hunspell `stem` function which analyzes the roots of words. Consult the Hunspell documentation for further understanding.\n\n```js\nvar nodehun = require('nodehun');\nvar affbuf = fs.readFileSync(somedirectory+'/en_US.aff');\nvar dictbuf = fs.readFileSync(somedirectory+'/en_US.dic');\nvar dict = new nodehun(affbuf,dictbuf);\n\ndict.stem('telling',function(err, stems){\n\tconsole.log(err, stems);\n\t// the output will be: null, [telling, tell]\n});\n```\n\nAsynchronous Invocation\n-----------------------\nInitializing the nodehun object can be bumpy if you're doing it a lot. A large dictionary can take up to 100ms to initialize. This is obviously unacceptable in applications that need on-the-fly dictionary creation. Therefore there is a static method on the nodehun object that allows you to initialize the dictionary object asynchronously, like so:\n\n```js\nvar nodehun = require('nodehun');\nvar affbuf = fs.readFileSync(somedirectory+'/en_US.aff');\nvar dictbuf = fs.readFileSync(somedirectory+'/en_US.dic');\n\nnodehun.createNewNodehun(affbuf,dictbuf,function(err,dict){\n\tif(!err)\n\t\tdict.spellSuggest('color',function(err, correct, suggestion){\n\t\t\tconsole.log(err, correct, suggestion);\n\t\t\t// because \"color\" is a defined word in the US English dictionary\n\t\t\t// the output will be: null, true, null\n\t\t});\n});\n```\n\nA Note About Creating Dictionaries\n----------------------------------\n\nIf you want to create a new Hunspell dictionary you will need a base affix file. I recommend simply using one of the base affix files from the open office dictionaries for the language you are creating a dictionary for. Once you get around to creating a dictionary read the hunspell documentation to learn how to properly flag the words. However, my guess is that the vast majority of people creating dictionaries out there will be creating a dictionary of proper nouns. Proper nouns simply require the \"M\" flag. This is what a dictionary of proper nouns might look like:\n\n\tAachen/M\n\taardvark/SM\n\tAaren/M\n\tAarhus/M\n\tAarika/M\n\tAaron/M\n\nNotice that the \"S\" flag denotes a proper noun that isn't capitalized, otherwise look in the docs.",
  "readmeFilename": "readme.md",
  "gitHead": "c9f17957eccce24e27b57ae616e8c67d228f84c3",
  "bugs": {
    "url": "https://github.com/nathanjsweet/nodehun/issues"
  },
  "homepage": "https://github.com/nathanjsweet/nodehun",
  "_id": "nodehun@0.2.5",
  "_shasum": "5394a50d98418c04806f781251c20326cf6fb200",
  "_from": "nodehun"
}
